import numpy as np

# Input values for the initial and final geometries
T_initial = np.array([0.73757, 3.05809, 173.07367, 84.4230, 0.000])  
T_final = np.array([0.73757, 3.79123, 84.4230, 5.62562, 0.0000])    

# Number of steps for LIIC
N = 10

# Calculate the interpolation vector using the formula
liic = T_final - T_initial

print('Initial geometry: ' + '\n', T_initial, '\n')
print('Final geometry: ' + '\n', T_final, '\n')
print('Interpolation vector: ' + '\n', liic, '\n')

# Initialize arrays to store interpolated geometries
interpolated_geometries = []

# Loop over steps and calculate interpolated geometries
print("Intermediate Geometries:")
for i in range(N):
    interpolated_geometry = T_initial + (i * liic) / (N - 1)
    interpolated_geometries.append(interpolated_geometry)
    print(f"Step {i}: {interpolated_geometry}")

# Print Z matrix for the initial geometry
print("\nZ Matrix for Initial Geometry:")
initial_z_matrix = [
    ["H"],
    ["H 1 " + str(T_initial[0])],
    ["H 1 " + str(T_initial[1]) + " 2 " + str(T_initial[2])],
    ["H 3 " + str(T_initial[0]) + " 2 " + str(T_initial[3]) + " 1 " + str(T_initial[4])]
]
for row in initial_z_matrix:
    print(" ".join(row))

# Print Z matrix for the final geometry
print("\nZ Matrix for Final Geometry:")
final_z_matrix = [
    ["H"],
    ["H 1 " + str(T_final[0])],
    ["H 1 " + str(T_final[1]) + " 2 " + str(T_final[2])],
    ["H 3 " + str(T_final[0]) + " 2 " + str(T_final[3]) + " 1 " + str(T_final[4])]
]
for row in final_z_matrix:
    print(" ".join(row))

# Print Z matrices for the intermediate geometries
print("\nZ Matrices for Intermediate Geometries:")
for i, geom in enumerate(interpolated_geometries):
    b1 = geom[0]
    b2 = geom[1]
    a1 = geom[2]
    a2 = geom[3]
    d1 = geom[4]
    z_matrix = [
        ["H"],
        ["H 1 " + str(b1)],
        ["H 1 " + str(b2) + " 2 " + str(a1)],
        ["H 3 " + str(b1) + " 2 " + str(a2) + " 1 " + str(d1)]
    ]
    print(f"Step {i}:")
    for row in z_matrix:
        print(" ".join(row))
    print()
